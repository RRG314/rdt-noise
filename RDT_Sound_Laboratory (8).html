<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RDT Sound Laboratory</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Courier New', monospace;
            background: linear-gradient(135deg, #0a0e27 0%, #1a1f3a 100%);
            color: #e0e0e0;
            padding: 15px;
            overflow-x: hidden;
            overflow-y: scroll;
            scroll-behavior: smooth;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        h1 {
            text-align: center;
            color: #00ff88;
            font-size: 2em;
            margin-bottom: 10px;
            text-shadow: 0 0 20px rgba(0, 255, 136, 0.6);
        }
        
        .subtitle {
            text-align: center;
            color: #88ccff;
            margin-bottom: 20px;
        }
        
        .layout {
            display: grid;
            grid-template-columns: 350px 1fr;
            gap: 20px;
        }
        
        @media (max-width: 1000px) {
            .layout {
                grid-template-columns: 1fr;
            }
        }
        
        .panel {
            background: rgba(20, 30, 50, 0.9);
            border: 2px solid #00ff88;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
        }
        
        .panel h2 {
            color: #00ff88;
            font-size: 1.2em;
            margin-bottom: 15px;
            border-bottom: 2px solid #00ff88;
            padding-bottom: 8px;
        }
        
        .slider-group {
            margin-bottom: 18px;
            padding: 12px;
            background: rgba(10, 14, 39, 0.6);
            border-radius: 8px;
        }
        
        .slider-group label {
            display: block;
            color: #88ccff;
            margin-bottom: 8px;
            font-size: 0.95em;
        }
        
        .slider-value {
            float: right;
            color: #00ff88;
            font-weight: bold;
        }
        
        input[type="range"] {
            width: 100%;
            height: 40px;
            -webkit-appearance: none;
            appearance: none;
            background: transparent;
        }
        
        input[type="range"]::-webkit-slider-track {
            height: 8px;
            background: linear-gradient(90deg, #1a3a5a 0%, #00ff88 100%);
            border-radius: 4px;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 24px;
            height: 24px;
            background: #00ff88;
            border-radius: 50%;
            cursor: pointer;
            margin-top: -8px;
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.8);
        }
        
        input[type="range"]::-moz-range-track {
            height: 8px;
            background: linear-gradient(90deg, #1a3a5a 0%, #00ff88 100%);
            border-radius: 4px;
        }
        
        input[type="range"]::-moz-range-thumb {
            width: 24px;
            height: 24px;
            background: #00ff88;
            border-radius: 50%;
            cursor: pointer;
            border: none;
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.8);
        }
        
        select {
            width: 100%;
            padding: 10px;
            background: #1a2a3a;
            color: #e0e0e0;
            border: 2px solid #00ff88;
            border-radius: 6px;
            font-size: 0.95em;
        }
        
        button {
            width: 100%;
            padding: 14px;
            margin: 8px 0;
            background: linear-gradient(135deg, #00ff88 0%, #00cc66 100%);
            color: #0a0e27;
            border: none;
            border-radius: 8px;
            font-size: 1em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 4px 15px rgba(0, 255, 136, 0.3);
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 255, 136, 0.5);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        button.secondary {
            background: linear-gradient(135deg, #88ccff 0%, #5599dd 100%);
        }
        
        button.compare {
            background: linear-gradient(135deg, #ff88cc 0%, #dd5599 100%);
        }
        
        .engine-selector {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .engine-btn {
            padding: 12px;
            background: #2a3a4a;
            border: 2px solid #555;
            color: #999;
            font-size: 0.9em;
        }
        
        .engine-btn.active {
            background: linear-gradient(135deg, #ff6b6b 0%, #cc5555 100%);
            border-color: #ff6b6b;
            color: white;
            box-shadow: 0 0 15px rgba(255, 107, 107, 0.5);
        }
        
        .status {
            text-align: center;
            padding: 12px;
            background: rgba(0, 255, 136, 0.2);
            border: 1px solid #00ff88;
            border-radius: 8px;
            margin-bottom: 20px;
            color: #00ff88;
            font-weight: bold;
        }
        
        .hidden {
            display: none;
        }
        
        canvas {
            width: 100%;
            background: #0a0e27;
            border-radius: 8px;
            margin-top: 10px;
            border: 1px solid #00ff88;
        }
        
        .canvas-3d {
            height: 400px;
            cursor: grab;
        }
        
        .canvas-3d:active {
            cursor: grabbing;
        }
        
        .canvas-2d {
            height: 200px;
        }
        
        .comparison-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }
        
        .comparison-card {
            background: rgba(10, 14, 39, 0.8);
            border: 2px solid #88ccff;
            border-radius: 8px;
            padding: 15px;
        }
        
        .comparison-card h3 {
            color: #88ccff;
            margin-bottom: 10px;
            font-size: 1em;
        }
        
        .comparison-card canvas {
            height: 150px;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
            margin-top: 15px;
        }
        
        .stat-box {
            background: rgba(10, 14, 39, 0.6);
            padding: 10px;
            border-radius: 6px;
            text-align: center;
        }
        
        .stat-label {
            color: #88ccff;
            font-size: 0.8em;
            margin-bottom: 5px;
        }
        
        .stat-value {
            color: #00ff88;
            font-size: 1.3em;
            font-weight: bold;
        }
        
        .view-toggle {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .view-toggle button {
            flex: 1;
            padding: 10px;
            font-size: 0.9em;
        }
        
        .preset-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }
        
        .preset-grid button {
            padding: 10px;
            font-size: 0.85em;
        }
        
        .info-box {
            background: rgba(0, 255, 136, 0.1);
            border-left: 4px solid #00ff88;
            padding: 10px;
            margin: 10px 0;
            font-size: 0.85em;
            color: #88ccff;
        }
        
        .warning-box {
            background: rgba(255, 107, 107, 0.1);
            border-left: 4px solid #ff6b6b;
            padding: 10px;
            margin: 10px 0;
            font-size: 0.85em;
            color: #ffcccc;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üî¨ RDT Sound Laboratory</h1>
        <div class="subtitle">Explore Pure Recursive Division Tree Audio</div>
        
        <div id="status" class="status hidden">Ready</div>
        
        <div class="layout">
            <!-- Left Panel: Controls -->
            <div>
                <div class="panel">
                    <h2>üéöÔ∏è Sound Engine</h2>
                    <div class="engine-selector">
                        <button class="engine-btn active" onclick="setEngine('rdt')" id="btn-rdt">
                            Pure RDT
                        </button>
                        <button class="engine-btn" onclick="setEngine('simple')" id="btn-simple">
                            Simple
                        </button>
                    </div>
                    <div class="info-box">
                        <strong>Pure RDT:</strong> True recursive field algorithm with 64-bit precision
                    </div>
                </div>
                
                <div class="panel">
                    <h2>üéÆ Controls</h2>
                    <button onclick="playSound()">‚ñ∂Ô∏è Generate & Play</button>
                    <button class="secondary" onclick="stopSound()">‚èπÔ∏è Stop</button>
                    <button class="compare" onclick="compareEngines()">üî¨ Compare Engines</button>
                    <button class="secondary" onclick="morphPresets()">üåà Morph Presets</button>
                    <button class="secondary" onclick="randomize()">üé≤ Randomize</button>
                </div>
                
                <div class="panel">
                    <h2>‚öôÔ∏è RDT Parameters</h2>
                    
                    <div class="slider-group">
                        <label>
                            œÜ-scale (RPHI)
                            <span class="slider-value" id="phi-val">1.00</span>
                        </label>
                        <input type="range" id="phi" min="50" max="150" value="100">
                    </div>
                    
                    <div class="slider-group">
                        <label>
                            Œî-scale (RDELTA)
                            <span class="slider-value" id="delta-val">1.00</span>
                        </label>
                        <input type="range" id="delta" min="50" max="150" value="100">
                    </div>
                    
                    <div class="slider-group">
                        <label>
                            Recursion Depth
                            <span class="slider-value" id="depth-val">4</span>
                        </label>
                        <input type="range" id="depth" min="1" max="10" value="4">
                    </div>
                    
                    <div class="slider-group">
                        <label>
                            Chaos Injection
                            <span class="slider-value" id="chaos-val">0.00</span>
                        </label>
                        <input type="range" id="chaos" min="0" max="100" value="0">
                    </div>
                    
                    <div class="slider-group">
                        <label>Spectral Color</label>
                        <select id="color">
                            <option value="flat">Flat (None)</option>
                            <option value="white">White Noise</option>
                            <option value="pink">Pink Noise (1/f)</option>
                            <option value="brown">Brown Noise (1/f¬≤)</option>
                            <option value="blue">Blue Noise (f)</option>
                            <option value="violet">Violet Noise (f¬≤)</option>
                        </select>
                    </div>
                    
                    <div class="slider-group">
                        <label>
                            Duration
                            <span class="slider-value" id="duration-val">2.0s</span>
                        </label>
                        <input type="range" id="duration" min="10" max="50" value="20">
                    </div>
                </div>
                
                <div class="panel">
                    <h2>üî¨ Advanced RDT</h2>
                    
                    <div class="slider-group">
                        <label>
                            Rotation Amount
                            <span class="slider-value" id="rotation-val">17</span>
                        </label>
                        <input type="range" id="rotation" min="1" max="31" value="17">
                    </div>
                    
                    <div class="slider-group">
                        <label>
                            Mix Rate
                            <span class="slider-value" id="mixrate-val">23</span>
                        </label>
                        <input type="range" id="mixrate" min="1" max="31" value="23">
                    </div>
                    
                    <div class="slider-group">
                        <label>
                            Field Coupling
                            <span class="slider-value" id="coupling-val">0.50</span>
                        </label>
                        <input type="range" id="coupling" min="0" max="100" value="50">
                    </div>
                    
                    <div class="slider-group">
                        <label>
                            State Feedback
                            <span class="slider-value" id="feedback-val">1.00</span>
                        </label>
                        <input type="range" id="feedback" min="0" max="200" value="100">
                    </div>
                    
                    <div class="slider-group">
                        <label>
                            Nonlinearity
                            <span class="slider-value" id="nonlinear-val">1.00</span>
                        </label>
                        <input type="range" id="nonlinear" min="0" max="200" value="100">
                    </div>
                    
                    <div class="slider-group">
                        <label>RDT Variant</label>
                        <select id="variant">
                            <option value="standard">Standard RDT</option>
                            <option value="double">Double Field</option>
                            <option value="split">Split State</option>
                            <option value="harmonic">Harmonic Mode</option>
                            <option value="twisted">Twisted Field</option>
                            <option value="resonant">Resonant</option>
                        </select>
                    </div>
                </div>
                
                <div class="panel">
                    <h2>üéØ Presets</h2>
                    <div class="preset-grid">
                        <button onclick="loadPreset('pure')">üî∑ Pure RDT</button>
                        <button onclick="loadPreset('deep')">üîä Deep Field</button>
                        <button onclick="loadPreset('crystal')">üíé Crystal</button>
                        <button onclick="loadPreset('chaos')">üå™Ô∏è Chaos</button>
                        <button onclick="loadPreset('pink')">üå∏ Pink RDT</button>
                        <button onclick="loadPreset('brown')">üü§ Brown RDT</button>
                        <button onclick="loadPreset('harmonic')">üéµ Harmonic</button>
                        <button onclick="loadPreset('twisted')">üåÄ Twisted</button>
                        <button onclick="loadPreset('resonant')">üì° Resonant</button>
                        <button onclick="loadPreset('minimal')">‚óΩ Minimal</button>
                        <button onclick="loadPreset('maximal')">‚¨õ Maximal</button>
                        <button onclick="loadPreset('ocean')">üåä Ocean</button>
                    </div>
                </div>
            </div>
            
            <!-- Right Panel: Visualizations -->
            <div>
                <div class="panel">
                    <h2>üìä Statistics</h2>
                    <div class="stats-grid">
                        <div class="stat-box">
                            <div class="stat-label">Engine</div>
                            <div class="stat-value" id="stat-engine">RDT</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-label">Peak Freq</div>
                            <div class="stat-value" id="stat-peak">--</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-label">RMS</div>
                            <div class="stat-value" id="stat-rms">--</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-label">Crest</div>
                            <div class="stat-value" id="stat-crest">--</div>
                        </div>
                    </div>
                </div>
                
                <div class="panel">
                    <h2>üìà Visualizations</h2>
                    <div class="view-toggle">
                        <button class="active" onclick="setView('2d')" id="view-2d">2D Views</button>
                        <button onclick="setView('3d')" id="view-3d">3D Waterfall</button>
                        <button onclick="setView('compare')" id="view-compare">Compare Engines</button>
                        <button onclick="setView('analysis')" id="view-analysis">Deep Analysis</button>
                        <button onclick="setView('variants')" id="view-variants">Variant Compare</button>
                    </div>
                    
                    <div id="view-2d-content">
                        <h3 style="color: #88ccff; margin: 15px 0 10px 0;">Waveform</h3>
                        <canvas id="waveform" class="canvas-2d"></canvas>
                        
                        <h3 style="color: #88ccff; margin: 15px 0 10px 0;">Frequency Spectrum</h3>
                        <canvas id="spectrum" class="canvas-2d"></canvas>
                        
                        <h3 style="color: #88ccff; margin: 15px 0 10px 0;">Spectrogram</h3>
                        <canvas id="spectrogram" class="canvas-2d"></canvas>
                    </div>
                    
                    <div id="view-3d-content" class="hidden">
                        <h3 style="color: #88ccff; margin: 15px 0 10px 0;">3D Spectral Waterfall (Drag to Rotate)</h3>
                        <canvas id="waterfall" class="canvas-3d"></canvas>
                        <div class="info-box">
                            Click and drag to rotate ‚Ä¢ Scroll to zoom
                        </div>
                    </div>
                    
                    <div id="view-compare-content" class="hidden">
                        <div style="margin-bottom: 15px;">
                            <button onclick="compareEngines()" style="width: 100%;">üî¨ Generate Comparison</button>
                        </div>
                        <div class="comparison-grid">
                            <div class="comparison-card">
                                <h3>Pure RDT Engine</h3>
                                <canvas id="compare-rdt"></canvas>
                            </div>
                            <div class="comparison-card">
                                <h3>Simple Engine</h3>
                                <canvas id="compare-simple"></canvas>
                            </div>
                        </div>
                        <div class="warning-box">
                            Comparison shows spectral differences between engines with same parameters
                        </div>
                    </div>
                    
                    <div id="view-analysis-content" class="hidden">
                        <h3 style="color: #88ccff; margin: 15px 0 10px 0;">Probability Distribution</h3>
                        <canvas id="histogram" class="canvas-2d"></canvas>
                        
                        <h3 style="color: #88ccff; margin: 15px 0 10px 0;">Autocorrelation Function</h3>
                        <canvas id="autocorr" class="canvas-2d"></canvas>
                        
                        <h3 style="color: #88ccff; margin: 15px 0 10px 0;">Phase Space (2D Embedding)</h3>
                        <canvas id="phase-space" class="canvas-2d"></canvas>
                        
                        <h3 style="color: #88ccff; margin: 15px 0 10px 0;">Spectral Slope Analysis</h3>
                        <canvas id="spectral-slope" class="canvas-2d"></canvas>
                        
                        <div class="info-box">
                            <strong>Deep Analysis:</strong> Statistical and geometric properties of RDT noise
                        </div>
                    </div>
                    
                    <div id="view-variants-content" class="hidden">
                        <div style="margin-bottom: 15px;">
                            <button onclick="drawVariantComparison()" style="width: 100%;">üî¨ Generate All Variants Comparison</button>
                        </div>
                        
                        <h3 style="color: #88ccff; margin: 15px 0 10px 0;">All 6 RDT Variants Compared</h3>
                        
                        <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 15px; margin-bottom: 20px;">
                            <div class="comparison-card">
                                <h3>Standard</h3>
                                <canvas id="variant-standard"></canvas>
                            </div>
                            <div class="comparison-card">
                                <h3>Double Field</h3>
                                <canvas id="variant-double"></canvas>
                            </div>
                            <div class="comparison-card">
                                <h3>Split State</h3>
                                <canvas id="variant-split"></canvas>
                            </div>
                            <div class="comparison-card">
                                <h3>Harmonic</h3>
                                <canvas id="variant-harmonic"></canvas>
                            </div>
                            <div class="comparison-card">
                                <h3>Twisted</h3>
                                <canvas id="variant-twisted"></canvas>
                            </div>
                            <div class="comparison-card">
                                <h3>Resonant</h3>
                                <canvas id="variant-resonant"></canvas>
                            </div>
                        </div>
                        
                        <h3 style="color: #88ccff; margin: 15px 0 10px 0;">Spectral Comparison</h3>
                        <canvas id="variant-spectra" class="canvas-2d"></canvas>
                        
                        <div class="warning-box">
                            All variants use same parameters - differences show geometric structure variations
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        // ============================================================
        // Global State
        // ============================================================
        
        let audioContext = null;
        let currentSource = null;
        let currentEngine = 'rdt';
        let currentView = '2d';
        let lastAudioData = null;
        let rotation3D = { x: 0.5, y: 0.3, zoom: 1 };
        let isDragging = false;
        let lastMouse = { x: 0, y: 0 };
        
        const RPHI0 = 12.0;
        const RDELTA0 = 6 * Math.sqrt(6);
        
        // ============================================================
        // Utility Functions
        // ============================================================
        
        function showStatus(msg, duration = 2000) {
            const el = document.getElementById('status');
            el.textContent = msg;
            el.classList.remove('hidden');
            setTimeout(() => el.classList.add('hidden'), duration);
        }
        
        function updateValues() {
            document.getElementById('phi-val').textContent = (document.getElementById('phi').value / 100).toFixed(2);
            document.getElementById('delta-val').textContent = (document.getElementById('delta').value / 100).toFixed(2);
            document.getElementById('depth-val').textContent = document.getElementById('depth').value;
            document.getElementById('chaos-val').textContent = (document.getElementById('chaos').value / 100).toFixed(2);
            document.getElementById('duration-val').textContent = (document.getElementById('duration').value / 10).toFixed(1) + 's';
            
            // Advanced parameters
            if (document.getElementById('rotation')) {
                document.getElementById('rotation-val').textContent = document.getElementById('rotation').value;
            }
            if (document.getElementById('mixrate')) {
                document.getElementById('mixrate-val').textContent = document.getElementById('mixrate').value;
            }
            if (document.getElementById('coupling')) {
                document.getElementById('coupling-val').textContent = (document.getElementById('coupling').value / 100).toFixed(2);
            }
            if (document.getElementById('feedback')) {
                document.getElementById('feedback-val').textContent = (document.getElementById('feedback').value / 100).toFixed(2);
            }
            if (document.getElementById('nonlinear')) {
                document.getElementById('nonlinear-val').textContent = (document.getElementById('nonlinear').value / 100).toFixed(2);
            }
        }
        
        function setEngine(engine) {
            currentEngine = engine;
            document.getElementById('btn-rdt').classList.toggle('active', engine === 'rdt');
            document.getElementById('btn-simple').classList.toggle('active', engine === 'simple');
            document.getElementById('stat-engine').textContent = engine === 'rdt' ? 'RDT' : 'Simple';
        }
        
        function setView(view) {
            console.log('üñºÔ∏è setView called with:', view);
            currentView = view;
            
            // Update button states
            ['2d', '3d', 'compare', 'analysis', 'variants'].forEach(v => {
                const btn = document.getElementById('view-' + v);
                const content = document.getElementById('view-' + v + '-content');
                
                if (btn) {
                    btn.classList.toggle('active', v === view);
                    console.log('Button view-' + v + ':', v === view ? 'active' : 'inactive');
                }
                
                if (content) {
                    content.classList.toggle('hidden', v !== view);
                    console.log('Content view-' + v + '-content:', v !== view ? 'hidden' : 'visible');
                } else {
                    console.warn('Content element not found: view-' + v + '-content');
                }
            });
            
            // Render existing audio data when switching views
            if (lastAudioData) {
                console.log('Rendering existing data for view:', view);
                
                // Small delay to ensure canvas is visible
                setTimeout(() => {
                    if (view === '2d') {
                        console.log('Drawing 2D views...');
                        drawWaveform(lastAudioData);
                        drawSpectrum(lastAudioData);
                        drawSpectrogram(lastAudioData);
                    } else if (view === '3d') {
                        console.log('Drawing 3D waterfall...');
                        draw3DWaterfall(lastAudioData);
                    } else if (view === 'analysis') {
                        console.log('Drawing deep analysis...');
                        drawDeepAnalysis(lastAudioData);
                    } else if (view === 'compare') {
                        console.log('Compare view - click Compare Engines button to generate');
                    } else if (view === 'variants') {
                        console.log('Variants view - click button to compare all variants');
                    }
                }, 50);
            } else {
                console.log('No audio data yet - generate sound first');
            }
            
            console.log('‚úÖ View switched to:', view);
        }
        
        // ============================================================
        // Pure RDT Engine (PAPER-ACCURATE IMPLEMENTATION)
        // ============================================================
        
        function generateRDTNoise(length, phiScale, deltaScale, depth, chaos) {
            console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
            console.log('üî¨ Generating RDT with paper-accurate math');
            console.log('Parameters:');
            console.log('  RœÜ =', RPHI0, '√ó scale', phiScale, '=', RPHI0 * phiScale);
            console.log('  RŒî =', RDELTA0.toFixed(4), '(6‚àö6) √ó scale', deltaScale, '=', (RDELTA0 * deltaScale).toFixed(4));
            console.log('  Depth:', depth);
            console.log('  Chaos:', chaos);
            console.log('  Length:', length, 'samples');
            
            const RPHI = RPHI0 * phiScale;  // Resonant rotation constant
            const RDELTA = RDELTA0 * deltaScale;  // Energy diffusion constant (6‚àö6)
            
            // Get advanced parameters
            const rotation = parseInt(document.getElementById('rotation')?.value || 17);
            const mixrate = parseInt(document.getElementById('mixrate')?.value || 23);
            const coupling = parseFloat(document.getElementById('coupling')?.value || 50) / 100;
            const feedback = parseFloat(document.getElementById('feedback')?.value || 100) / 100;
            const nonlinear = parseFloat(document.getElementById('nonlinear')?.value || 100) / 100;
            const variant = document.getElementById('variant')?.value || 'standard';
            
            // Initialize state F‚ÇÄ with œÄ-based constants (digits of œÄ in hex)
            // This represents F‚ÇÄ(x) - the initial recursive diffusion field
            let F = new Uint32Array([
                0x243F6A88, 0x85A308D3, 0x13198A2E, 0x03707344,  // œÄ digits
                0xA4093822, 0x299F31D0, 0x082EFA98, 0xEC4E6C89,
                0x452821E6, 0x38D01377, 0xBE5466CF, 0x34E90C6C,
                0xC0AC29B7, 0xC97C50DD, 0x3F84D5B5, 0xB5470917
            ]);
            
            // Previous state for Œî‚Çô(x) calculation
            let F_prev = new Uint32Array(F);
            
            const samples = new Float32Array(length);
            
            console.log('Starting recursive diffusion with depth =', depth);
            
            // Recursive Diffusion: iterate through depth levels
            // At each iteration n, we compute F‚Çô‚Çä‚ÇÅ from F‚Çô
            for (let n = 0; n < depth; n++) {
                console.log('  Iteration n =', n);
                
                // Split state into left (L) and right (R) for resonance coupling
                const L = F.slice(0, 8);
                const R = F.slice(8, 16);
                
                // ========================================================
                // PAPER EQUATION: Compute Local Energy E‚Çô
                // E‚Çô = (RœÜ¬∑F‚Çô‚Çã‚ÇÅ + RŒî¬∑‚àÇF‚Çô‚Çã‚ÇÅ/‚àÇx) mod 2‚Å∂‚Å¥
                // ========================================================
                
                // Compute local difference operator Œî‚Çô(x)
                // Œî‚Çô(x) = F‚Çô(x) ‚àí F‚Çô‚Çã‚ÇÅ(x) + (‚àá¬∑F‚Çô‚Çã‚ÇÅ(x)) / œÜ
                const delta = new Uint32Array(16);
                for (let i = 0; i < 16; i++) {
                    const diff = (F[i] - F_prev[i]) >>> 0;
                    const grad = (F_prev[(i + 1) % 16] - F_prev[i]) >>> 0;
                    const phi_term = (grad / 1.618033988749895) >>> 0;
                    delta[i] = (diff + phi_term) >>> 0;
                }
                
                // Energy field array E
                const E = new Uint32Array(16);
                
                // Variant-specific field mixing (different geometric interpretations)
                for (let i = 0; i < 8; i++) {
                    let energy_term;
                    
                    switch(variant) {
                        case 'standard':
                            // Standard resonant coupling
                            energy_term = (L[i] ^ R[i]) >>> 0;
                            break;
                            
                        case 'double':
                            // Double field - independent resonance
                            const e1 = (L[i] ^ R[i]) >>> 0;
                            const e2 = (L[(i + 4) % 8] ^ R[(i + 4) % 8]) >>> 0;
                            energy_term = (e1 + e2) >>> 0;
                            break;
                            
                        case 'split':
                            // Split state - alternating operations
                            energy_term = (i % 2 === 0) ? 
                                (L[i] + R[i]) >>> 0 : 
                                (L[i] ^ R[i]) >>> 0;
                            break;
                            
                        case 'harmonic':
                            // Harmonic mode - periodic modulo
                            energy_term = ((L[i] ^ R[i]) % 65521) >>> 0;
                            break;
                            
                        case 'twisted':
                            // Twisted field - non-local coupling
                            energy_term = (L[i] ^ R[(8 - i - 1) % 8]) >>> 0;
                            break;
                            
                        case 'resonant':
                            // Resonant - feedback from previous iteration
                            energy_term = (L[i] ^ R[i] ^ (n > 0 ? F_prev[i] : 0)) >>> 0;
                            break;
                            
                        default:
                            energy_term = (L[i] ^ R[i]) >>> 0;
                    }
                    
                    // Apply paper equation: E‚Çô = (RœÜ¬∑F‚Çô‚Çã‚ÇÅ + RŒî¬∑‚àÇF‚Çô‚Çã‚ÇÅ/‚àÇx) mod 2‚Å∂‚Å¥
                    E[i] = (
                        Math.floor(RPHI * coupling) * F_prev[i] + 
                        Math.floor(RDELTA * coupling) * delta[i] + 
                        energy_term
                    ) >>> 0;
                    
                    // Mirror for right half
                    E[i + 8] = (
                        Math.floor(RPHI * coupling) * F_prev[i + 8] + 
                        Math.floor(RDELTA * coupling) * delta[i + 8] + 
                        energy_term
                    ) >>> 0;
                }
                
                // ========================================================
                // PAPER EQUATION: Compute Resonant Phase Œ¶‚Çô
                // Œ¶‚Çô = sin(E‚Çô / RŒî) + cos(E‚Çô / RœÜ)
                // ========================================================
                
                const Phi = new Uint32Array(16);
                for (let i = 0; i < 16; i++) {
                    // Compute phase from energy
                    const sin_term = Math.sin((E[i] / RDELTA) * nonlinear);
                    const cos_term = Math.cos((E[i] / RPHI) * nonlinear);
                    const phase_value = sin_term + cos_term;
                    
                    // Convert to rotation amount (mod 64 for bit rotation)
                    // Scale phase [-2, 2] to [0, 63]
                    Phi[i] = Math.floor(((phase_value + 2) / 4) * 63) & 63;
                }
                
                // ========================================================
                // PAPER EQUATION: Recursive Diffusion Operator
                // D[F‚Çô] = F‚Çô‚Çã‚ÇÅ ‚äï rotl‚ÇÜ‚ÇÑ(E‚Çô, Œ¶‚Çô mod 64)
                // ========================================================
                
                const F_next = new Uint32Array(16);
                
                for (let i = 0; i < 16; i++) {
                    // Apply rotation with phase-dependent amount
                    const rotAmount = (Phi[i] + n * rotation + i * mixrate) & 31;
                    const rotated = rotl32(E[i], rotAmount);
                    
                    // Apply diffusion operator: XOR with previous state
                    F_next[i] = (F_prev[i] ^ rotated) >>> 0;
                    
                    // Apply feedback scaling
                    if (feedback !== 1.0) {
                        const fb_scaled = Math.floor(F_next[i] * feedback) >>> 0;
                        F_next[i] = (F_next[i] ^ fb_scaled) >>> 0;
                    }
                }
                
                // ========================================================
                // Golden ratio permutation (maintains entropy bound)
                // This ensures RÃÉ ‚â§ 2 per Entropic Escape Theorem
                // ========================================================
                
                for (let i = 0; i < 16; i++) {
                    F_next[i] = (F_next[(i + 1) % 16] ^ 0x9E3779B9) >>> 0;  // œÜ‚Åª¬π in binary
                }
                
                // ========================================================
                // Chaos injection (optional stochastic perturbation)
                // ========================================================
                
                if (chaos > 0) {
                    for (let i = 0; i < 16; i++) {
                        const noise = Math.floor(Math.random() * 256);
                        F_next[i] = (F_next[i] ^ (noise & Math.floor(chaos * 255))) >>> 0;
                    }
                }
                
                // Update for next iteration
                F_prev = new Uint32Array(F);
                F = F_next;
            }
            
            console.log('Recursive diffusion complete, converting to audio samples');
            
            // ========================================================
            // Convert state field to audio samples
            // Extract bytes deterministically and normalize to [-1, 1]
            // ========================================================
            
            // The final state F contains 16 uint32 values = 64 bytes total
            // We cycle through these bytes to generate audio samples
            let byteIndex = 0;
            
            for (let i = 0; i < length; i++) {
                const wordIndex = byteIndex % 16;                    // Which uint32 word
                const byteInWord = Math.floor(byteIndex / 16) % 4;  // Which byte in that word
                
                // Extract byte from the word
                const byte = (F[wordIndex] >> (byteInWord * 8)) & 0xFF;
                
                // Normalize to [-1, 1] range for audio
                samples[i] = (byte / 127.5) - 1.0;
                
                byteIndex++;
            }
            
            console.log('‚úÖ RDT generation complete:', samples.length, 'samples');
            console.log('üìä First 10 samples:', Array.from(samples.slice(0, 10)).map(v => v.toFixed(4)));
            console.log('üìä State checksum:', F.reduce((sum, val) => (sum + val) >>> 0, 0));
            console.log('üìä Sample checksum:', samples.slice(0, 100).reduce((sum, v) => sum + v, 0).toFixed(6));
            console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
            console.log('üí° If chaos=0, these values should be IDENTICAL each time!');
            console.log('');
            
            return samples;
        }
        
        function rotl32(x, n) {
            return ((x << n) | (x >>> (32 - n))) >>> 0;
        }
        
        // ============================================================
        // Simple Engine (For Comparison)
        // ============================================================
        
        function generateSimpleNoise(length, seed) {
            const samples = new Float32Array(length);
            let x = seed;
            
            for (let i = 0; i < length; i++) {
                x = (x * 1664525 + 1013904223) >>> 0;
                samples[i] = (x / 0xFFFFFFFF) * 2 - 1;
            }
            
            return samples;
        }
        
        // ============================================================
        // Color Filters
        // ============================================================
        
        function applyColorFilter(data, mode) {
            if (mode === 'flat' || mode === 'white') return data;
            
            const filtered = new Float32Array(data.length);
            const n = data.length;
            
            switch(mode) {
                case 'pink':
                    let b0 = 0, b1 = 0, b2 = 0;
                    for (let i = 0; i < n; i++) {
                        b0 = 0.99886 * b0 + data[i] * 0.0555179;
                        b1 = 0.99332 * b1 + data[i] * 0.0750759;
                        b2 = 0.96900 * b2 + data[i] * 0.1538520;
                        filtered[i] = b0 + b1 + b2 + data[i] * 0.3104856;
                    }
                    break;
                    
                case 'brown':
                    let acc = 0;
                    for (let i = 0; i < n; i++) {
                        acc += data[i] * 0.02;
                        filtered[i] = acc;
                        acc *= 0.998;
                    }
                    break;
                    
                case 'blue':
                    filtered[0] = data[0];
                    for (let i = 1; i < n; i++) {
                        filtered[i] = data[i] - data[i-1] * 0.95;
                    }
                    break;
                    
                case 'violet':
                    filtered[0] = 0;
                    filtered[1] = data[1] - data[0];
                    for (let i = 2; i < n; i++) {
                        filtered[i] = data[i] - 2 * data[i-1] + data[i-2];
                    }
                    break;
                    
                default:
                    return data;
            }
            
            // Normalize
            let max = 0;
            for (let i = 0; i < n; i++) {
                max = Math.max(max, Math.abs(filtered[i]));
            }
            if (max > 0) {
                for (let i = 0; i < n; i++) {
                    filtered[i] /= max;
                }
            }
            
            return filtered;
        }
        
        // ============================================================
        // Audio Generation
        // ============================================================
        
        function generateAudio() {
            const phi = document.getElementById('phi').value / 100;
            const delta = document.getElementById('delta').value / 100;
            const depth = parseInt(document.getElementById('depth').value);
            const chaos = document.getElementById('chaos').value / 100;
            const color = document.getElementById('color').value;
            const duration = document.getElementById('duration').value / 10;
            
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
            
            const sampleRate = audioContext.sampleRate;
            const samples = Math.floor(sampleRate * duration);
            
            let data;
            
            if (currentEngine === 'rdt') {
                data = generateRDTNoise(samples, phi, delta, depth, chaos);
            } else {
                const seed = Math.floor((phi * 1000 + delta * 2000) * 12345);
                data = generateSimpleNoise(samples, seed);
                
                if (chaos > 0) {
                    for (let i = 0; i < samples; i++) {
                        const noise = Math.random() * 2 - 1;
                        data[i] = data[i] * (1 - chaos) + noise * chaos;
                    }
                }
            }
            
            // Apply color filter
            data = applyColorFilter(data, color);
            
            // Normalize
            let max = 0;
            for (let i = 0; i < samples; i++) {
                max = Math.max(max, Math.abs(data[i]));
            }
            if (max > 0) {
                for (let i = 0; i < samples; i++) {
                    data[i] = data[i] / max * 0.8;
                }
            }
            
            return data;
        }
        
        function playSound() {
            showStatus('üéµ Generating ' + (currentEngine === 'rdt' ? 'Pure RDT' : 'Simple') + ' sound...', 3000);
            
            setTimeout(() => {
                try {
                    const data = generateAudio();
                    lastAudioData = data;
                    
                    // Update statistics
                    updateStats(data);
                    
                    // Update visualizations based on CURRENT view
                    console.log('Current view is:', currentView);
                    updateCurrentView();
                    
                    // Play audio
                    if (currentSource) {
                        currentSource.stop();
                    }
                    
                    const buffer = audioContext.createBuffer(1, data.length, audioContext.sampleRate);
                    const channelData = buffer.getChannelData(0);
                    channelData.set(data);
                    
                    currentSource = audioContext.createBufferSource();
                    currentSource.buffer = buffer;
                    currentSource.connect(audioContext.destination);
                    currentSource.start();
                    
                    showStatus('‚ñ∂Ô∏è Playing!', 2000);
                } catch (e) {
                    console.error('Error:', e);
                    showStatus('‚ùå Error generating sound');
                }
            }, 100);
        }
        
        function updateCurrentView() {
            if (!lastAudioData) return;
            
            console.log('Updating visualizations for view:', currentView);
            
            if (currentView === '2d') {
                drawWaveform(lastAudioData);
                drawSpectrum(lastAudioData);
                drawSpectrogram(lastAudioData);
            } else if (currentView === '3d') {
                setTimeout(() => draw3DWaterfall(lastAudioData), 100);
            } else if (currentView === 'analysis') {
                setTimeout(() => drawDeepAnalysis(lastAudioData), 100);
            } else if (currentView === 'variants') {
                // Don't auto-update variant compare - it generates its own data
                console.log('Variant view - use Variant Compare button to regenerate');
            }
            // Don't update compare view - it has its own button
        }
        
        function stopSound() {
            if (currentSource) {
                currentSource.stop();
                currentSource = null;
                showStatus('‚èπÔ∏è Stopped', 1000);
            }
        }
        
        // ============================================================
        // Statistics
        // ============================================================
        
        function updateStats(data) {
            // RMS
            let rms = 0;
            for (let i = 0; i < data.length; i++) {
                rms += data[i] * data[i];
            }
            rms = Math.sqrt(rms / data.length);
            
            // Peak and Crest Factor
            let peak = 0;
            for (let i = 0; i < data.length; i++) {
                peak = Math.max(peak, Math.abs(data[i]));
            }
            const crest = peak / (rms + 1e-10);
            
            // Estimate dominant frequency (zero-crossing)
            let crossings = 0;
            for (let i = 1; i < data.length; i++) {
                if ((data[i-1] < 0 && data[i] >= 0) || (data[i-1] >= 0 && data[i] < 0)) {
                    crossings++;
                }
            }
            const freq = (crossings / 2) * audioContext.sampleRate / data.length;
            
            document.getElementById('stat-peak').textContent = freq.toFixed(0) + 'Hz';
            document.getElementById('stat-rms').textContent = rms.toFixed(3);
            document.getElementById('stat-crest').textContent = crest.toFixed(2);
        }
        
        // ============================================================
        // Deep Analysis Visualizations
        // ============================================================
        
        function drawDeepAnalysis(data) {
            console.log('üìä Drawing deep analysis...');
            drawHistogram(data);
            drawAutocorrelation(data);
            drawPhaseSpace(data);
            drawSpectralSlope(data);
        }
        
        function drawHistogram(data) {
            const canvas = document.getElementById('histogram');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            
            ctx.fillStyle = '#0a0e27';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Create histogram bins
            const bins = 50;
            const counts = new Array(bins).fill(0);
            
            for (let i = 0; i < data.length; i++) {
                const bin = Math.floor(((data[i] + 1) / 2) * bins);
                const idx = Math.max(0, Math.min(bins - 1, bin));
                counts[idx]++;
            }
            
            // Normalize
            const maxCount = Math.max(...counts);
            
            // Draw bars
            const barWidth = canvas.width / bins;
            for (let i = 0; i < bins; i++) {
                const height = (counts[i] / maxCount) * canvas.height * 0.9;
                const x = i * barWidth;
                const y = canvas.height - height;
                
                const hue = 180 - (i / bins) * 60;
                ctx.fillStyle = `hsl(${hue}, 70%, 50%)`;
                ctx.fillRect(x, y, barWidth - 1, height);
            }
            
            // Draw expected Gaussian for comparison
            ctx.strokeStyle = 'rgba(255, 100, 100, 0.7)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            
            for (let i = 0; i < bins; i++) {
                const x = (i / bins - 0.5) * 4; // -2 to 2
                const gaussian = Math.exp(-x * x / 2) * maxCount * 0.8;
                const px = (i / bins) * canvas.width;
                const py = canvas.height - (gaussian / maxCount) * canvas.height * 0.9;
                
                if (i === 0) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
            }
            ctx.stroke();
            
            // Labels
            ctx.fillStyle = '#88ccff';
            ctx.font = '12px monospace';
            ctx.fillText('Distribution (bars) vs Gaussian (red line)', 10, 20);
        }
        
        function drawAutocorrelation(data) {
            const canvas = document.getElementById('autocorr');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.height;
            
            ctx.fillStyle = '#0a0e27';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            const maxLag = 200;
            const acf = new Array(maxLag);
            
            // Compute mean
            let mean = 0;
            for (let i = 0; i < data.length; i++) {
                mean += data[i];
            }
            mean /= data.length;
            
            // Compute variance
            let variance = 0;
            for (let i = 0; i < data.length; i++) {
                variance += (data[i] - mean) * (data[i] - mean);
            }
            variance /= data.length;
            
            // Compute autocorrelation
            for (let lag = 0; lag < maxLag; lag++) {
                let corr = 0;
                const n = data.length - lag;
                
                for (let i = 0; i < n; i++) {
                    corr += (data[i] - mean) * (data[i + lag] - mean);
                }
                
                acf[lag] = corr / (n * variance);
            }
            
            // Draw
            ctx.strokeStyle = '#00ff88';
            ctx.lineWidth = 2;
            ctx.beginPath();
            
            const centerY = canvas.height / 2;
            
            for (let i = 0; i < maxLag; i++) {
                const x = (i / maxLag) * canvas.width;
                const y = centerY - acf[i] * centerY * 0.9;
                
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            
            ctx.stroke();
            
            // Zero line
            ctx.strokeStyle = 'rgba(136, 204, 255, 0.3)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(0, centerY);
            ctx.lineTo(canvas.width, centerY);
            ctx.stroke();
            
            // Labels
            ctx.fillStyle = '#88ccff';
            ctx.font = '12px monospace';
            ctx.fillText('Autocorrelation (lag 0-200)', 10, 20);
            ctx.fillText('Fast decay = high entropy', 10, canvas.height - 10);
        }
        
        function drawPhaseSpace(data) {
            const canvas = document.getElementById('phase-space');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            
            ctx.fillStyle = '#0a0e27';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // 2D embedding: plot x(t) vs x(t+delay)
            const delay = 10;
            const alpha = 0.05;
            
            ctx.fillStyle = `rgba(0, 255, 136, ${alpha})`;
            
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const scale = Math.min(canvas.width, canvas.height) * 0.4;
            
            for (let i = 0; i < data.length - delay; i += 2) {
                const x = centerX + data[i] * scale;
                const y = centerY - data[i + delay] * scale;
                
                ctx.fillRect(x - 1, y - 1, 2, 2);
            }
            
            // Axes
            ctx.strokeStyle = 'rgba(136, 204, 255, 0.3)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(0, centerY);
            ctx.lineTo(canvas.width, centerY);
            ctx.moveTo(centerX, 0);
            ctx.lineTo(centerX, canvas.height);
            ctx.stroke();
            
            // Labels
            ctx.fillStyle = '#88ccff';
            ctx.font = '12px monospace';
            ctx.fillText('x(t) vs x(t+10) - Phase Space Embedding', 10, 20);
        }
        
        function drawSpectralSlope(data) {
            const canvas = document.getElementById('spectral-slope');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            
            ctx.fillStyle = '#0a0e27';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Compute power spectrum via autocorrelation
            const nFreq = 100;
            const spectrum = new Array(nFreq);
            
            for (let f = 0; f < nFreq; f++) {
                let power = 0;
                const samples = Math.min(500, data.length - f);
                
                for (let i = 0; i < samples; i++) {
                    power += Math.abs(data[i] * data[i + f]);
                }
                
                spectrum[f] = power / samples;
            }
            
            // Log-log plot
            ctx.strokeStyle = '#00ff88';
            ctx.lineWidth = 2;
            ctx.beginPath();
            
            let maxPower = 0;
            for (let i = 1; i < nFreq; i++) {
                maxPower = Math.max(maxPower, spectrum[i]);
            }
            
            for (let i = 1; i < nFreq; i++) {
                const logF = Math.log(i + 1);
                const logP = Math.log(spectrum[i] + 1e-10);
                
                const x = (logF / Math.log(nFreq)) * canvas.width;
                const y = canvas.height - ((logP - Math.log(1e-10)) / (Math.log(maxPower) - Math.log(1e-10))) * canvas.height * 0.9;
                
                if (i === 1) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            
            ctx.stroke();
            
            // Reference slopes
            // 1/f (pink noise)
            ctx.strokeStyle = 'rgba(255, 100, 100, 0.5)';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(0, canvas.height * 0.2);
            ctx.lineTo(canvas.width, canvas.height * 0.8);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Labels
            ctx.fillStyle = '#88ccff';
            ctx.font = '12px monospace';
            ctx.fillText('Log-Log Power Spectrum', 10, 20);
            ctx.fillText('Green = RDT ‚Ä¢ Red dashed = 1/f reference', 10, canvas.height - 10);
        }
        
        // ============================================================
        // Variant Comparison Visualizations
        // ============================================================
        
        function drawVariantComparison() {
            console.log('üî¨ Comparing all variants...');
            showStatus('Generating all 6 variants...', 5000);
            
            const phi = document.getElementById('phi').value / 100;
            const delta = document.getElementById('delta').value / 100;
            const depth = parseInt(document.getElementById('depth').value);
            const chaos = document.getElementById('chaos').value / 100;
            
            console.log('Parameters:', { phi, delta, depth, chaos });
            
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
            
            const sampleRate = audioContext.sampleRate;
            const samples = Math.floor(sampleRate * 0.5); // 0.5 sec each
            
            const variants = ['standard', 'double', 'split', 'harmonic', 'twisted', 'resonant'];
            const variantData = {};
            
            // Save original variant setting
            const variantSelect = document.getElementById('variant');
            const originalVariant = variantSelect ? variantSelect.value : 'standard';
            
            console.log('Original variant:', originalVariant);
            
            // Generate all variants
            variants.forEach((variant, idx) => {
                console.log(`Generating variant ${idx + 1}/6: ${variant}`);
                
                try {
                    // Set variant
                    if (variantSelect) {
                        variantSelect.value = variant;
                    }
                    
                    // Generate with this variant
                    const data = generateRDTNoise(samples, phi, delta, depth, chaos);
                    variantData[variant] = data;
                    
                    console.log(`  ‚úì Generated ${data.length} samples for ${variant}`);
                    
                    // Draw individual waveform
                    drawVariantWaveform('variant-' + variant, data);
                    
                } catch (e) {
                    console.error(`Error generating ${variant}:`, e);
                    showStatus(`‚ùå Error generating ${variant}`, 3000);
                }
            });
            
            // Restore original variant
            if (variantSelect) {
                variantSelect.value = originalVariant;
            }
            
            console.log('All variants generated, drawing spectral comparison...');
            
            // Draw combined spectral comparison
            try {
                drawVariantSpectra(variantData);
                showStatus('‚úÖ All variants compared!', 2000);
            } catch (e) {
                console.error('Error drawing spectral comparison:', e);
                showStatus('‚ùå Error drawing spectra', 3000);
            }
        }
        
        function drawVariantWaveform(canvasId, data) {
            const canvas = document.getElementById(canvasId);
            if (!canvas) {
                console.warn(`Canvas ${canvasId} not found`);
                return;
            }
            
            console.log(`Drawing waveform on ${canvasId}, data length: ${data.length}`);
            
            const ctx = canvas.getContext('2d');
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            
            if (canvas.width === 0 || canvas.height === 0) {
                console.warn(`Canvas ${canvasId} has zero size: ${canvas.width}x${canvas.height}`);
                return;
            }
            
            ctx.fillStyle = '#0a0e27';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.strokeStyle = '#00ff88';
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            
            const step = Math.max(1, Math.floor(data.length / canvas.width));
            const centerY = canvas.height / 2;
            
            for (let x = 0; x < canvas.width; x++) {
                const i = Math.min(x * step, data.length - 1);
                const y = centerY - data[i] * centerY * 0.8;
                
                if (x === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            
            ctx.stroke();
            console.log(`  ‚úì Drew waveform on ${canvasId}`);
        }
        
        function drawVariantSpectra(variantData) {
            const canvas = document.getElementById('variant-spectra');
            if (!canvas) {
                console.warn('Canvas variant-spectra not found');
                return;
            }
            
            console.log('Drawing variant spectra comparison...');
            console.log('Variant data keys:', Object.keys(variantData));
            
            const ctx = canvas.getContext('2d');
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            
            if (canvas.width === 0 || canvas.height === 0) {
                console.warn(`Canvas variant-spectra has zero size: ${canvas.width}x${canvas.height}`);
                return;
            }
            
            ctx.fillStyle = '#0a0e27';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            const variants = ['standard', 'double', 'split', 'harmonic', 'twisted', 'resonant'];
            const colors = ['#00ff88', '#ff6b6b', '#4ecdc4', '#ffe66d', '#a8e6cf', '#ff88cc'];
            
            variants.forEach((variant, idx) => {
                const data = variantData[variant];
                
                if (!data) {
                    console.warn(`No data for variant: ${variant}`);
                    return;
                }
                
                console.log(`Drawing spectrum for ${variant}, color: ${colors[idx]}`);
                
                // Simple spectrum
                const bins = 100;
                const spectrum = new Float32Array(bins);
                
                for (let b = 0; b < bins; b++) {
                    const lag = Math.floor(b * data.length / bins / 4);
                    let corr = 0;
                    const n = Math.min(500, data.length - lag);
                    
                    for (let i = 0; i < n; i++) {
                        corr += data[i] * data[i + lag];
                    }
                    spectrum[b] = Math.abs(corr / n);
                }
                
                // Normalize
                let max = 0;
                for (let i = 0; i < bins; i++) {
                    max = Math.max(max, spectrum[i]);
                }
                
                if (max === 0) {
                    console.warn(`Max spectrum is zero for ${variant}`);
                    return;
                }
                
                // Draw
                ctx.strokeStyle = colors[idx];
                ctx.lineWidth = 2;
                ctx.beginPath();
                
                for (let i = 0; i < bins; i++) {
                    const x = (i / bins) * canvas.width;
                    const y = canvas.height - (spectrum[i] / max) * canvas.height * 0.85;
                    
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                
                ctx.stroke();
                console.log(`  ‚úì Drew spectrum for ${variant}`);
            });
            
            // Legend
            ctx.fillStyle = '#88ccff';
            ctx.font = '11px monospace';
            let legendY = 15;
            variants.forEach((variant, idx) => {
                ctx.fillStyle = colors[idx];
                ctx.fillRect(10, legendY, 15, 10);
                ctx.fillStyle = '#e0e0e0';
                ctx.fillText(variant, 30, legendY + 9);
                legendY += 15;
            });
            
            console.log('‚úì Variant spectra comparison complete');
        }
        
        // ============================================================
        // 2D Visualizations
        // ============================================================
        
        function drawWaveform(data) {
            const canvas = document.getElementById('waveform');
            const ctx = canvas.getContext('2d');
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            
            ctx.fillStyle = '#0a0e27';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.strokeStyle = '#00ff88';
            ctx.lineWidth = 2;
            ctx.beginPath();
            
            const step = Math.floor(data.length / canvas.width);
            const centerY = canvas.height / 2;
            
            for (let x = 0; x < canvas.width; x++) {
                const i = x * step;
                const y = centerY - data[i] * centerY * 0.9;
                
                if (x === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            
            ctx.stroke();
            
            // Center line
            ctx.strokeStyle = 'rgba(136, 204, 255, 0.3)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(0, centerY);
            ctx.lineTo(canvas.width, centerY);
            ctx.stroke();
        }
        
        function drawSpectrum(data) {
            const canvas = document.getElementById('spectrum');
            const ctx = canvas.getContext('2d');
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            
            ctx.fillStyle = '#0a0e27';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Simple spectrum via autocorrelation
            const bins = 200;
            const spectrum = new Float32Array(bins);
            
            for (let b = 0; b < bins; b++) {
                const lag = Math.floor(b * data.length / bins / 4);
                let corr = 0;
                const samples = Math.min(1000, data.length - lag);
                
                for (let i = 0; i < samples; i++) {
                    corr += data[i] * data[i + lag];
                }
                spectrum[b] = Math.abs(corr / samples);
            }
            
            // Draw
            ctx.strokeStyle = '#00ff88';
            ctx.lineWidth = 2;
            ctx.beginPath();
            
            let max = 0;
            for (let i = 0; i < bins; i++) {
                max = Math.max(max, spectrum[i]);
            }
            
            for (let i = 0; i < bins; i++) {
                const x = (i / bins) * canvas.width;
                const y = canvas.height - (spectrum[i] / max) * canvas.height * 0.9;
                
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            
            ctx.stroke();
            
            // Grid
            ctx.strokeStyle = 'rgba(136, 204, 255, 0.2)';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 4; i++) {
                const y = (i / 4) * canvas.height;
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
        }
        
        function drawSpectrogram(data) {
            const canvas = document.getElementById('spectrogram');
            const ctx = canvas.getContext('2d');
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            
            ctx.fillStyle = '#0a0e27';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            const windowSize = 512;
            const hopSize = 128;
            const numWindows = Math.min(canvas.width, Math.floor((data.length - windowSize) / hopSize));
            
            for (let w = 0; w < numWindows; w++) {
                const start = w * hopSize;
                const window = data.slice(start, start + windowSize);
                
                // Simple energy per frequency band
                const bands = 50;
                for (let b = 0; b < bands; b++) {
                    const freqStart = Math.floor(b * windowSize / bands);
                    const freqEnd = Math.floor((b + 1) * windowSize / bands);
                    
                    let energy = 0;
                    for (let i = freqStart; i < freqEnd && i < window.length; i++) {
                        energy += window[i] * window[i];
                    }
                    energy = Math.sqrt(energy / (freqEnd - freqStart));
                    
                    const x = (w / numWindows) * canvas.width;
                    const y = canvas.height - ((b + 1) / bands) * canvas.height;
                    const height = canvas.height / bands;
                    
                    const intensity = Math.min(1, energy * 10);
                    const r = Math.floor(intensity * 255);
                    const g = Math.floor(intensity * 255 * 0.5);
                    const b_color = Math.floor((1 - intensity) * 100);
                    
                    ctx.fillStyle = `rgb(${r}, ${g}, ${b_color})`;
                    ctx.fillRect(x, y, canvas.width / numWindows + 1, height + 1);
                }
            }
        }
        
        // ============================================================
        // 3D Waterfall
        // ============================================================
        
        function draw3DWaterfall(data) {
            const canvas = document.getElementById('waterfall');
            const ctx = canvas.getContext('2d');
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            
            ctx.fillStyle = '#0a0e27';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            const windowSize = 512;
            const hopSize = 256;
            const maxWindows = 40;
            const numWindows = Math.min(maxWindows, Math.floor((data.length - windowSize) / hopSize));
            
            const spectra = [];
            for (let w = 0; w < numWindows; w++) {
                const start = w * hopSize;
                const window = data.slice(start, start + windowSize);
                
                const spectrum = [];
                for (let i = 0; i < 80; i++) {
                    let val = 0;
                    const samples = 5;
                    for (let j = 0; j < samples; j++) {
                        const idx = i * samples + j;
                        if (idx < window.length) {
                            val += Math.abs(window[idx]);
                        }
                    }
                    spectrum.push(val / samples);
                }
                spectra.push(spectrum);
            }
            
            // 3D projection
            const cx = canvas.width / 2;
            const cy = canvas.height / 2;
            const scale = Math.min(canvas.width, canvas.height) / 100 * rotation3D.zoom;
            
            const cosX = Math.cos(rotation3D.x);
            const sinX = Math.sin(rotation3D.x);
            const cosY = Math.cos(rotation3D.y);
            const sinY = Math.sin(rotation3D.y);
            
            for (let t = 0; t < numWindows; t++) {
                const spectrum = spectra[t];
                
                ctx.strokeStyle = `hsl(${180 + t * 180 / numWindows}, 70%, 50%)`;
                ctx.lineWidth = 2;
                ctx.beginPath();
                
                let first = true;
                
                for (let f = 0; f < spectrum.length; f++) {
                    const x = (f - 40) * 0.8;
                    const y = spectrum[f] * 30;
                    const z = (t - numWindows / 2) * 2;
                    
                    // Rotate
                    let x1 = x;
                    let y1 = y * cosX - z * sinX;
                    let z1 = y * sinX + z * cosX;
                    
                    let x2 = x1 * cosY + z1 * sinY;
                    let y2 = y1;
                    let z2 = -x1 * sinY + z1 * cosY;
                    
                    // Project
                    const perspective = 1 / (1 + z2 / 500);
                    const screenX = cx + x2 * scale * perspective;
                    const screenY = cy - y2 * scale * perspective;
                    
                    if (first) {
                        ctx.moveTo(screenX, screenY);
                        first = false;
                    } else {
                        ctx.lineTo(screenX, screenY);
                    }
                }
                
                ctx.stroke();
            }
        }
        
        // ============================================================
        // Comparison Mode
        // ============================================================
        
        function compareEngines() {
            console.log('üî¨ Compare Engines called');
            showStatus('üî¨ Comparing engines...', 3000);
            
            // Switch to compare view first
            console.log('Switching to compare view...');
            setView('compare');
            
            setTimeout(() => {
                try {
                    console.log('Starting comparison generation...');
                    
                    const phi = document.getElementById('phi').value / 100;
                    const delta = document.getElementById('delta').value / 100;
                    const depth = parseInt(document.getElementById('depth').value);
                    const chaos = document.getElementById('chaos').value / 100;
                    const color = document.getElementById('color').value;
                    
                    console.log('Parameters:', { phi, delta, depth, chaos, color });
                    
                    if (!audioContext) {
                        console.log('Creating audio context...');
                        audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    }
                    
                    const sampleRate = audioContext.sampleRate;
                    const samples = Math.floor(sampleRate * 2);
                    console.log('Generating', samples, 'samples at', sampleRate, 'Hz');
                    
                    // Generate RDT
                    console.log('Generating RDT noise...');
                    const rdtData = generateRDTNoise(samples, phi, delta, depth, chaos);
                    console.log('RDT generated:', rdtData.length, 'samples');
                    
                    // Generate Simple
                    console.log('Generating Simple noise...');
                    const seed = Math.floor((phi * 1000 + delta * 2000) * 12345);
                    let simpleData = generateSimpleNoise(samples, seed);
                    console.log('Simple generated:', simpleData.length, 'samples');
                    
                    if (chaos > 0) {
                        console.log('Applying chaos to Simple...');
                        for (let i = 0; i < samples; i++) {
                            const noise = Math.random() * 2 - 1;
                            simpleData[i] = simpleData[i] * (1 - chaos) + noise * chaos;
                        }
                    }
                    
                    // Apply same color filter
                    console.log('Applying color filters...');
                    const rdtFiltered = applyColorFilter(rdtData, color);
                    const simpleFiltered = applyColorFilter(simpleData, color);
                    console.log('Filters applied');
                    
                    // Draw comparisons
                    console.log('Drawing RDT comparison...');
                    drawComparisonWaveform('compare-rdt', rdtFiltered);
                    console.log('Drawing Simple comparison...');
                    drawComparisonWaveform('compare-simple', simpleFiltered);
                    console.log('Comparisons drawn');
                    
                    showStatus('‚úÖ Comparison ready!', 2000);
                    console.log('‚úÖ Comparison complete!');
                    
                } catch (e) {
                    console.error('‚ùå Compare error:', e);
                    showStatus('‚ùå Comparison failed: ' + e.message, 3000);
                }
            }, 100);
        }
        
        function drawComparisonWaveform(canvasId, data) {
            console.log('üé® Drawing comparison for:', canvasId, 'with', data.length, 'samples');
            
            const canvas = document.getElementById(canvasId);
            if (!canvas) {
                console.error('‚ùå Canvas not found:', canvasId);
                return;
            }
            
            console.log('Canvas found:', canvasId, 'size:', canvas.offsetWidth, 'x', canvas.offsetHeight);
            
            const ctx = canvas.getContext('2d');
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            
            console.log('Canvas dimensions set:', canvas.width, 'x', canvas.height);
            
            ctx.fillStyle = '#0a0e27';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Waveform
            ctx.strokeStyle = '#00ff88';
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            
            const step = Math.floor(data.length / canvas.width);
            const centerY = canvas.height / 2;
            
            for (let x = 0; x < canvas.width; x++) {
                const i = x * step;
                const y = centerY - data[i] * centerY * 0.8;
                
                if (x === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            
            ctx.stroke();
            console.log('‚úÖ Waveform drawn for:', canvasId);
            
            // Prevent scroll on these canvases
            canvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                e.stopPropagation();
            }, { passive: false });
        }
        
        // ============================================================
        // Presets
        // ============================================================
        
        function loadPreset(name) {
            const presets = {
                pure: { 
                    engine: 'rdt', phi: 100, delta: 100, depth: 4, chaos: 0, color: 'flat',
                    rotation: 17, mixrate: 23, coupling: 50, feedback: 100, nonlinear: 100, variant: 'standard'
                },
                deep: { 
                    engine: 'rdt', phi: 70, delta: 130, depth: 8, chaos: 0, color: 'flat',
                    rotation: 17, mixrate: 23, coupling: 80, feedback: 120, nonlinear: 100, variant: 'standard'
                },
                crystal: { 
                    engine: 'rdt', phi: 140, delta: 80, depth: 2, chaos: 0, color: 'white',
                    rotation: 11, mixrate: 19, coupling: 30, feedback: 80, nonlinear: 100, variant: 'standard'
                },
                chaos: { 
                    engine: 'rdt', phi: 120, delta: 120, depth: 10, chaos: 50, color: 'flat',
                    rotation: 29, mixrate: 31, coupling: 70, feedback: 150, nonlinear: 150, variant: 'standard'
                },
                pink: { 
                    engine: 'rdt', phi: 100, delta: 100, depth: 5, chaos: 0, color: 'pink',
                    rotation: 17, mixrate: 23, coupling: 50, feedback: 100, nonlinear: 100, variant: 'standard'
                },
                brown: { 
                    engine: 'rdt', phi: 90, delta: 110, depth: 6, chaos: 0, color: 'brown',
                    rotation: 17, mixrate: 23, coupling: 60, feedback: 100, nonlinear: 100, variant: 'standard'
                },
                harmonic: {
                    engine: 'rdt', phi: 100, delta: 100, depth: 5, chaos: 0, color: 'flat',
                    rotation: 13, mixrate: 17, coupling: 50, feedback: 100, nonlinear: 80, variant: 'harmonic'
                },
                twisted: {
                    engine: 'rdt', phi: 110, delta: 90, depth: 6, chaos: 10, color: 'flat',
                    rotation: 19, mixrate: 29, coupling: 60, feedback: 130, nonlinear: 120, variant: 'twisted'
                },
                resonant: {
                    engine: 'rdt', phi: 95, delta: 105, depth: 7, chaos: 0, color: 'pink',
                    rotation: 17, mixrate: 23, coupling: 70, feedback: 150, nonlinear: 100, variant: 'resonant'
                },
                minimal: {
                    engine: 'rdt', phi: 100, delta: 100, depth: 1, chaos: 0, color: 'flat',
                    rotation: 7, mixrate: 11, coupling: 20, feedback: 50, nonlinear: 50, variant: 'standard'
                },
                maximal: {
                    engine: 'rdt', phi: 150, delta: 150, depth: 10, chaos: 80, color: 'violet',
                    rotation: 31, mixrate: 31, coupling: 100, feedback: 200, nonlinear: 200, variant: 'double'
                },
                ocean: {
                    engine: 'rdt', phi: 80, delta: 120, depth: 8, chaos: 20, color: 'brown',
                    rotation: 13, mixrate: 19, coupling: 70, feedback: 110, nonlinear: 90, variant: 'resonant'
                }
            };
            
            const p = presets[name];
            if (!p) return;
            
            setEngine(p.engine);
            document.getElementById('phi').value = p.phi;
            document.getElementById('delta').value = p.delta;
            document.getElementById('depth').value = p.depth;
            document.getElementById('chaos').value = p.chaos;
            document.getElementById('color').value = p.color;
            
            // Set advanced parameters
            if (document.getElementById('rotation')) {
                document.getElementById('rotation').value = p.rotation;
                document.getElementById('mixrate').value = p.mixrate;
                document.getElementById('coupling').value = p.coupling;
                document.getElementById('feedback').value = p.feedback;
                document.getElementById('nonlinear').value = p.nonlinear;
                document.getElementById('variant').value = p.variant;
            }
            
            updateValues();
            showStatus('Loaded preset: ' + name, 1500);
            
            setTimeout(() => playSound(), 500);
        }
        
        // ============================================================
        // 3D Mouse Controls
        // ============================================================
        
        const waterfall = document.getElementById('waterfall');
        
        waterfall.addEventListener('mousedown', (e) => {
            isDragging = true;
            lastMouse = { x: e.clientX, y: e.clientY };
        });
        
        waterfall.addEventListener('mousemove', (e) => {
            if (isDragging) {
                const dx = e.clientX - lastMouse.x;
                const dy = e.clientY - lastMouse.y;
                
                rotation3D.y += dx * 0.01;
                rotation3D.x += dy * 0.01;
                
                lastMouse = { x: e.clientX, y: e.clientY };
                
                if (lastAudioData) {
                    draw3DWaterfall(lastAudioData);
                }
            }
        });
        
        waterfall.addEventListener('mouseup', () => {
            isDragging = false;
        });
        
        waterfall.addEventListener('wheel', (e) => {
            e.preventDefault();
            e.stopPropagation();
            rotation3D.zoom *= (1 - e.deltaY * 0.0005);
            rotation3D.zoom = Math.max(0.5, Math.min(2, rotation3D.zoom));
            
            if (lastAudioData) {
                requestAnimationFrame(() => draw3DWaterfall(lastAudioData));
            }
        }, { passive: false });
        
        // ============================================================
        // Special Features
        // ============================================================
        
        function morphPresets() {
            showStatus('üåà Morphing between presets...', 10000);
            
            const presetNames = ['pure', 'deep', 'crystal', 'harmonic', 'twisted', 'resonant'];
            let currentIdx = 0;
            
            const morphInterval = setInterval(() => {
                if (currentIdx >= presetNames.length) {
                    clearInterval(morphInterval);
                    showStatus('‚úÖ Morph complete!', 2000);
                    return;
                }
                
                loadPreset(presetNames[currentIdx]);
                currentIdx++;
            }, 3000);
        }
        
        function randomize() {
            showStatus('üé≤ Randomizing parameters...', 2000);
            
            const phi = 50 + Math.floor(Math.random() * 100);
            const delta = 50 + Math.floor(Math.random() * 100);
            const depth = 1 + Math.floor(Math.random() * 10);
            const chaos = Math.floor(Math.random() * 100);
            const rotation = 1 + Math.floor(Math.random() * 31);
            const mixrate = 1 + Math.floor(Math.random() * 31);
            const coupling = Math.floor(Math.random() * 100);
            const feedback = Math.floor(Math.random() * 200);
            const nonlinear = Math.floor(Math.random() * 200);
            
            const colors = ['flat', 'white', 'pink', 'brown', 'blue', 'violet'];
            const color = colors[Math.floor(Math.random() * colors.length)];
            
            const variants = ['standard', 'double', 'split', 'harmonic', 'twisted', 'resonant'];
            const variant = variants[Math.floor(Math.random() * variants.length)];
            
            document.getElementById('phi').value = phi;
            document.getElementById('delta').value = delta;
            document.getElementById('depth').value = depth;
            document.getElementById('chaos').value = chaos;
            document.getElementById('color').value = color;
            
            if (document.getElementById('rotation')) {
                document.getElementById('rotation').value = rotation;
                document.getElementById('mixrate').value = mixrate;
                document.getElementById('coupling').value = coupling;
                document.getElementById('feedback').value = feedback;
                document.getElementById('nonlinear').value = nonlinear;
                document.getElementById('variant').value = variant;
            }
            
            updateValues();
            
            setTimeout(() => playSound(), 500);
        }
        
        // ============================================================
        // Initialize
        // ============================================================
        
        function init() {
            updateValues();
            
            document.querySelectorAll('input[type="range"]').forEach(slider => {
                slider.addEventListener('input', updateValues);
                slider.addEventListener('change', updateValues);
            });
            
            // Prevent wheel scroll on all canvases except waterfall (which needs it for zoom)
            const canvases2d = [
                'waveform', 'spectrum', 'spectrogram', 
                'compare-rdt', 'compare-simple',
                'histogram', 'autocorr', 'phase-space', 'spectral-slope',
                'variant-standard', 'variant-double', 'variant-split',
                'variant-harmonic', 'variant-twisted', 'variant-resonant',
                'variant-spectra'
            ];
            
            canvases2d.forEach(id => {
                const canvas = document.getElementById(id);
                if (canvas) {
                    canvas.addEventListener('wheel', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                    }, { passive: false });
                }
            });
            
            // Initialize compare and variant canvases with placeholder
            initializePlaceholders();
            
            showStatus('üî¨ RDT Sound Laboratory Ready', 2000);
        }
        
        function initializePlaceholders() {
            // Compare canvases
            drawPlaceholder('compare-rdt', 'Click "Generate Comparison" above');
            drawPlaceholder('compare-simple', 'Click "Generate Comparison" above');
            
            // Variant canvases
            const variants = ['standard', 'double', 'split', 'harmonic', 'twisted', 'resonant'];
            variants.forEach(v => {
                drawPlaceholder('variant-' + v, 'Click button above');
            });
            drawPlaceholder('variant-spectra', 'Click "Generate All Variants" above');
        }
        
        function drawPlaceholder(canvasId, text) {
            const canvas = document.getElementById(canvasId);
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            
            ctx.fillStyle = '#0a0e27';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.fillStyle = 'rgba(136, 204, 255, 0.3)';
            ctx.font = '14px monospace';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, canvas.width / 2, canvas.height / 2);
        }
        
        window.addEventListener('load', init);
    </script>
</body>
</html>
